<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>移动升级</title>
	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/fontawesome-all.css">
	<link rel="stylesheet" href="css/common.css">
	<link rel="stylesheet" href="css/index.css">
</head>
<style>
	.box{
		width: 100px;
		height: 100px;
		background:red;
		position: absolute;
		/*top:100px;
		left: 0px;	*/
	}
	button{
		width: 50px;
		height: 50px;
	}
</style>
<body>
	<button>&lt;</button><button>&gt;</button>
	<div class="box transition"></div>
</body>

<script src="js/jquery-1.12.4.js"></script>
<script src="js/transition.js"></script>
<script>
	;(function($){
		function Slient($elem){
			this.$elem=$elem;
			this.$elem.removeClass('transition');
			this.currentX=parseFloat(this.$elem.css('left'));  //parseFloat括号之内的是带像素的,进行转化,化成不带像素的
			this.currentY=parseFloat(this.$elem.css('top'));
		}
		Slient.prototype={
			constructor:Slient,
			to:function(x,y){
				x= (typeof  x == 'number') ? x: this.currentX;  
				y= (typeof  y == 'number') ? y: this.currentY;  
				if(x== this.currentX && y==this.currentY)  return;//如果传进来的值和原来的值相等,就不走下一步,直接返回
				console.log('move...');
				this.$elem.trigger('move');
				this.$elem.css({
					left:x,
					top:y
				});
				this.$elem.trigger('moved');
				this.currentX=x;  //把移动过后的值赋给current重新进行判断
				this.currentY=y;
			},
			x:function(x){
				this.to(x);
			},
			y:function(y){
				this.to(null,y);
			}
		}






		function Css3($elem){
			this.$elem=$elem;
			this.$elem.addClass('transition');
			this.currentX=parseFloat(this.$elem.css('left'));  //parseFloat括号之内的是带像素的,进行转化,化成不带像素的
			this.currentY=parseFloat(this.$elem.css('top'));

			//当没有初始的left和top时,初始化添加left和top
			this.$elem.css({
				left:this.currentX,
				top:this.currentY
			})
		}
		Css3.prototype={
			constructor:Css3,
			to:function(x,y){
				var self=this;
				x= (typeof  x == 'number') ? x: this.currentX;  
				y= (typeof  y == 'number') ? y: this.currentY;  
				if(x== this.currentX && y==this.currentY)  return;
					//如果传进来的值和原来的值相等,就不走下一步,直接返回
				// console.log('move...');
				this.$elem.trigger('move');

				//监听过渡完成事件(等移动好后再打印moved)
				this.$elem
				.off(kuazhu.transition.end)
				.one(kuazhu.transition.end,function(){
					self.$elem.trigger('moved');
				})

				this.$elem.css({
					left:x,
					top:y
				});
				this.currentX=x;  //把移动过后的值赋给current重新进行判断
				this.currentY=y;
			},
			x:function(x){
				this.to(x);
			},
			y:function(y){
				this.to(null,y);
			}
		}



		var obj=new Css3($('.box'));

		$('.box').on('move moved',function(ev){
			console.log(ev.type);
		})

		$('button').eq(0).on('click',function(){
			// obj.to(null,100);
			obj.to(0,100);

		})
		$('button').eq(1).on('click',function(){
			obj.to(200,200);
			// obj.to(200)
			// obj.to(null,200)
		})
	})(jQuery)
</script>
</html>